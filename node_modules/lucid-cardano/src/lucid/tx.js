import { C } from '../core';
import { utxoToCore, assetsToValue, getAddressDetails, unixTimeToSlot, unixTimeToSlotTestnet, } from '../utils';
import { Lucid } from './lucid';
import { TxComplete } from './txComplete';
export class Tx {
    static new() {
        const t = new this();
        t.txBuilder = C.TransactionBuilder.new(Lucid.txBuilderConfig);
        return t;
    }
    collectFrom(utxos, redeemer) {
        utxos.forEach((utxo) => {
            const utxoCloned = { ...utxo };
            if (utxo.datumHash && !utxo.datum) {
            }
            const coreUtxo = utxoToCore(utxoCloned);
            this.txBuilder.add_input(C.Address.from_bech32(utxo.address), coreUtxo.input(), coreUtxo.output().amount(), redeemer &&
                C.ScriptWitness.new_plutus_witness(C.PlutusWitness.new(C.PlutusData.from_bytes(Buffer.from(redeemer, 'hex')), utxoCloned.datum &&
                    C.PlutusData.from_bytes(Buffer.from(utxoCloned.datum, 'hex')))));
        });
        return this;
    }
    mintAssets(assets, redeemer) {
        const units = Object.keys(assets);
        const policyId = units[0].slice(0, 56);
        const mintAssets = C.MintAssets.new();
        units.forEach((unit) => {
            if (unit.slice(0, 56) !== policyId)
                throw new Error('Only one Policy Id allowed. You can chain multiple mintAssets events together if you need to mint assets with different Policy Ids.');
            mintAssets.insert(C.AssetName.new(Buffer.from(unit.slice(56), 'hex')), C.Int.from_str(assets[unit].toString()));
        });
        const scriptHash = C.ScriptHash.from_bytes(Buffer.from(policyId, 'hex'));
        this.txBuilder.add_mint(scriptHash, mintAssets, redeemer &&
            C.ScriptWitness.new_plutus_witness(C.PlutusWitness.new(C.PlutusData.from_bytes(Buffer.from(redeemer, 'hex')))));
        return this;
    }
    payToAddress(address, assets) {
        const output = C.TransactionOutput.new(C.Address.from_bech32(address), assetsToValue(assets));
        this.txBuilder.add_output(output);
        return this;
    }
    payToContract(address, datum, assets) {
        const plutusData = C.PlutusData.from_bytes(Buffer.from(datum, 'hex'));
        const output = C.TransactionOutput.new(C.Address.from_bech32(address), assetsToValue(assets));
        output.set_datum(C.Datum.new_data_hash(C.hash_plutus_data(plutusData)));
        this.txBuilder.add_output(output);
        this.txBuilder.add_plutus_data(plutusData);
        return this;
    }
    delegateTo(rewardAddress, poolId, redeemer) {
        const detailedAddress = getAddressDetails(rewardAddress);
        if (detailedAddress.type !== 'Reward')
            throw new Error('Not a reward address provided');
        const credential = detailedAddress.credentialType === 'Key'
            ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_bytes(Buffer.from(detailedAddress.stakeKeyHash, 'hex')))
            : C.StakeCredential.from_scripthash(C.Ed25519KeyHash.from_bytes(Buffer.from(detailedAddress.stakeKeyHash, 'hex')));
        this.txBuilder.add_certificate(C.Certificate.new_stake_delegation(C.StakeDelegation.new(credential, C.Ed25519KeyHash.from_bech32(poolId))), redeemer &&
            C.ScriptWitness.new_plutus_witness(C.PlutusWitness.new(C.PlutusData.from_bytes(Buffer.from(redeemer, 'hex')))));
        return this;
    }
    registerStake(rewardAddress) {
        const detailedAddress = getAddressDetails(rewardAddress);
        if (detailedAddress.type !== 'Reward')
            throw new Error('Not a reward address provided');
        const credential = detailedAddress.credentialType === 'Key'
            ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_bytes(Buffer.from(detailedAddress.stakeKeyHash, 'hex')))
            : C.StakeCredential.from_scripthash(C.Ed25519KeyHash.from_bytes(Buffer.from(detailedAddress.stakeKeyHash, 'hex')));
        this.txBuilder.add_certificate(C.Certificate.new_stake_registration(C.StakeRegistration.new(credential)));
        return this;
    }
    deregisterStake(rewardAddress, redeemer) {
        const detailedAddress = getAddressDetails(rewardAddress);
        if (detailedAddress.type !== 'Reward')
            throw new Error('Not a reward address provided');
        const credential = detailedAddress.credentialType === 'Key'
            ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_bytes(Buffer.from(detailedAddress.stakeKeyHash, 'hex')))
            : C.StakeCredential.from_scripthash(C.Ed25519KeyHash.from_bytes(Buffer.from(detailedAddress.stakeKeyHash, 'hex')));
        this.txBuilder.add_certificate(C.Certificate.new_stake_deregistration(C.StakeDeregistration.new(credential)), redeemer &&
            C.ScriptWitness.new_plutus_witness(C.PlutusWitness.new(C.PlutusData.from_bytes(Buffer.from(redeemer, 'hex')))));
        return this;
    }
    withdraw(rewardAddress, amount, redeemer) {
        this.txBuilder.add_withdrawal(C.RewardAddress.from_address(C.Address.from_bech32(rewardAddress)), C.BigNum.from_str(amount.toString()), redeemer &&
            C.ScriptWitness.new_plutus_witness(C.PlutusWitness.new(C.PlutusData.from_bytes(Buffer.from(redeemer, 'hex')))));
        return this;
    }
    addSigner(address) {
        const addressDetailed = getAddressDetails(address);
        const keyHash = addressDetailed.type === 'Reward'
            ? addressDetailed.stakeKeyHash
            : addressDetailed.paymentKeyHash;
        this.txBuilder.add_required_signer(C.Ed25519KeyHash.from_bytes(Buffer.from(keyHash, 'hex')));
        return this;
    }
    validFrom(unixTime) {
        const slot = Lucid.network === 'Mainnet'
            ? unixTimeToSlot(unixTime)
            : unixTimeToSlotTestnet(unixTime);
        this.txBuilder.set_validity_start_interval(C.BigNum.from_str(slot.toString()));
        return this;
    }
    validTo(unixTime) {
        const slot = Lucid.network === 'Mainnet'
            ? unixTimeToSlot(unixTime)
            : unixTimeToSlotTestnet(unixTime);
        this.txBuilder.set_ttl(C.BigNum.from_str(slot.toString()));
        return this;
    }
    attachMetadata(label, metadata) {
        this.txBuilder.add_json_metadatum(C.BigNum.from_str(label.toString()), JSON.stringify(metadata));
        return this;
    }
    attachMetadataWithConversion(label, metadata) {
        this.txBuilder.add_json_metadatum_with_schema(C.BigNum.from_str(label.toString()), JSON.stringify(metadata), C.MetadataJsonSchema.BasicConversions);
        return this;
    }
    attachSpendingValidator(spendingValidator) {
        attachScript(this, spendingValidator);
        return this;
    }
    attachMintingPolicy(mintingPolicy) {
        attachScript(this, mintingPolicy);
        return this;
    }
    attachCertificateValidator(certValidator) {
        attachScript(this, certValidator);
        return this;
    }
    attachWithdrawalValidator(withdrawalValidator) {
        attachScript(this, withdrawalValidator);
        return this;
    }
    applyIf(condition, callback) {
        if (condition)
            callback(this);
        return this;
    }
    async complete() {
        const utxos = await Lucid.wallet.getUtxosCore();
        if (this.txBuilder.redeemers()?.len() > 0) {
            const collateral = await Lucid.wallet.getCollateralCore();
            if (collateral.length <= 0)
                throw new Error('No collateral UTxO found.');
            collateral.slice(0, 2).forEach((utxo) => {
                this.txBuilder.add_collateral(utxo.output().address(), utxo.input());
            });
        }
        try {
            this.txBuilder.add_inputs_from(utxos, C.CoinSelectionStrategyCIP2.RandomImproveMultiAsset);
        }
        catch (e) {
            try {
                this.txBuilder.add_inputs_from(utxos, C.CoinSelectionStrategyCIP2.RandomImprove);
            }
            catch (e) {
                try {
                    this.txBuilder.add_inputs_from(utxos, C.CoinSelectionStrategyCIP2.LargestFirstMultiAsset);
                }
                catch (e) {
                    try {
                        this.txBuilder.add_inputs_from(utxos, C.CoinSelectionStrategyCIP2.LargestFirst);
                    }
                    catch (e) {
                        throw new Error('Coin selection failed. Not enough funds or no fitting UTxOs found.');
                    }
                }
            }
        }
        this.txBuilder.add_change_if_needed(C.Address.from_bech32(Lucid.wallet.address));
        return new TxComplete(await this.txBuilder.construct());
    }
}
const attachScript = (tx, script) => {
    if (script.type === 'Native') {
        tx.txBuilder.add_native_script(C.NativeScript.from_bytes(Buffer.from(script.script, 'hex')));
    }
    if (script.type === 'Plutus') {
        tx.txBuilder.add_plutus_script(C.PlutusScript.from_bytes(Buffer.from(script.script, 'hex')));
    }
};
//# sourceMappingURL=tx.js.map